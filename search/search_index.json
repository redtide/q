{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Q is a cross-platform C++ library for Audio Digital Signal Processing. Aptly named after the \"Q factor\", a dimensionless parameter that describes the quality of a resonant circuit, the Q DSP Library is designed to be simple and elegant, as the simplicity of its name suggests, and efficient enough to run on small microcontrollers.</p> <p>Q leverages the power of modern C++ and efficient use of functional programming techniques, especially function composition using fine-grained and reusable function objects (both stateless and stateful), to simplify complex DSP programming tasks without sacrificing readability.</p> <p>Q is the host of some experimental Music related DSP facilities such as Virtual Pickups (Virtual pickup placement simulator) and Bitstream Autocorrelation (An extremely fast and efficient pitch detection scheme) the author has accumulated over the years as part of research and development, and will continue to evolve to accommodate more facilities necessary for the fulfillment of various Music related projects.</p> <p>The library is Open Source and released under the very liberal MIT license.</p>"},{"location":"#documentation","title":"Documentation","text":"<ol> <li>Design and Architecture</li> <li>Setup and Installation</li> <li>Hello, World</li> <li>Hello, Universe</li> <li>Fundamentals</li> </ol>"},{"location":"#about-the-author","title":"About the Author","text":"<p>Joel got into electronics and programming in the 80s because almost everything in music, his first love, is becoming electronic and digital. Since then, he builds his own guitars, effect boxes and synths. He enjoys playing distortion-laden rock guitar, composes and produces his own music in his home studio.</p> <p>Joel de Guzman is the principal architect and engineer at Cycfi Research and a consultant at Ciere Consulting. He is a software engineer specializing in advanced C++ and an advocate of Open Source. He has authored a number of highly successful Open Source projects such as Boost.Spirit, Boost.Phoenix and Boost.Fusion. These libraries are all part of the Boost Libraries, a well respected, peer-reviewed, Open Source, collaborative development effort.</p>"},{"location":"api/","title":"API","text":""},{"location":"api/#file-structure","title":"File Structure","text":"<p>The library is organized with this simplified directory structure:</p> <pre><code>|_ docs\n|_ example\n|_ q_io\n|  |_ external\n|  |_ include\n|  |_ src\n|_ q_lib\n|  |_ include\n|_ test\n</code></pre> <p><code>docs</code> is where this documentation resides. <code>example</code> contains self-contained and easy to understand c++ files that demonstrate various features of the library. <code>q_io</code> is the Audio and MIDI I/O layer which contains <code>external</code> \u20143rd party libraries used by the <code>q_io</code> module, <code>include</code> \u2014Header files and <code>src</code> \u2014Source files. <code>q_lib</code> is the header-only core DSP library in the <code>include</code> sub-directory. Finally, the <code>test</code> directory contains a bunch of c++ files for testing the library.</p>"},{"location":"api/#namespace","title":"Namespace","text":"<p>All entities in the Q library are placed in namespace <code>cycfi::q</code>. Everywhere in this documentation, we will be using a namespace alias to make the code less verbose:</p> <pre><code>   namespace q = cycfi::q;\n</code></pre>"},{"location":"api/#functors","title":"Functors","text":"<p>In the world of electronic music, there are processors and synthesizers, the definitions of which are somewhat overlapping and differ only on one specific point: that processors take in one or more input value(s) and produces one or more output value(s), whereas a synthesizer does not take in any inputs at all.</p> <p>In the Q world, both processors and synthesizers are just functors \u2014C++ function objects, which are basic building blocks that can be composed to form more complex functions. A functor can have zero or more input values and produces one or more output values (typically just one, but in certain cases, two or more output values may be returned in the form of C++ tuples).</p> <p>Syntactically, you use these just like any other function. So, for instance, for a single input functor:</p> <p><pre><code>   float r = f(s);\n</code></pre> where <code>s</code> is the input value, and <code>f(s)</code> returns a result and stores it in the variable <code>r</code>. Typical audio processor functors in the Q DSP library work on 32-bit <code>float</code> input samples with the normal -1.0 to 1.0 range.</p>"},{"location":"api/#values","title":"Values","text":"<p>Values are not restricted to sampled signals, however. For an example, signal envelopes are best represented in the decibel domain, and so dynamic-range processors such as compressors and expanders take <code>decibel</code> as inputs and return <code>decibel</code> results. For example:</p> <pre><code>   decibel gain = comp(env);\n</code></pre> <p>Another example, oscillators work on phase-angle inputs and return output samples:</p> <pre><code>   float out = sin(phase++);\n</code></pre> <p>The Q DSP library has a rich set of such types:</p> <ul> <li><code>float</code>: Typical sample data type -1.0 to 1.0 (or beyond for some   computational headroom).</li> <li><code>frequency</code>: Cycles per second (Hz).</li> <li><code>duration</code> : A time span (seconds, milliseconds, etc.)</li> <li><code>period</code> : The inverse of frequency</li> <li><code>phase</code>: Fixed point 1.31 format where 31 bits are fractional. <code>phase</code>   represents 0 to 2\u03c0 phase values suitable for oscillators.</li> <li><code>decibel</code>: Ratio of one value to another on a logarithmic scale (dB)</li> </ul> <p>The Q DSP library is typeful and typesafe. You can not mismatch values of different types such as <code>frequency</code> and <code>decibel</code>, for example. Such potentially disastrous mistakes can happen if all values are just raw floating point types.</p> <p>Values do not have implicit conversion to raw types, however, except for <code>decibel</code>, which is special because it operates on the logarithmic domain, comparison and arithmetic with raw types are possible. For example:</p> <pre><code>   auto harmonic = 440_Hz * 4; // 440_Hz is a frequency literal (see below)\n</code></pre>"},{"location":"api/#values-api","title":"Values API","text":"<p>See the Values API page for the complete API.</p>"},{"location":"api/#literals","title":"Literals","text":"<p>To augment the wealth of value types, the Q DSP library makes abundant use of C++ user-defined literals. Here are some examples:</p> <pre><code>   auto c4 = 261.6256_Hz;\nauto threshold = -36_dB;\nauto coef = 1.0 - (2_pi * 1_kHz / sps);\nauto attack = 20_ms;\n</code></pre> <p>To use these literals, include the <code>literals.hpp</code> header:</p> <pre><code>   #include &lt;q/support/literals.hpp&gt;\n</code></pre> <p>then use the <code>literals</code> namespace somewhere in a scope where you need it:</p> <pre><code>   using namespace q::literals;\n</code></pre> <p>Here's the list of available literals:</p> <pre><code>   // frequency\nconstexpr frequency operator \"\"  _Hz(long double val);\nconstexpr frequency operator \"\"  _Hz(unsigned long long int val);\nconstexpr frequency operator \"\"  _KHz(long double val);\nconstexpr frequency operator \"\"  _KHz(unsigned long long int val);\nconstexpr frequency operator \"\"  _kHz(long double val);\nconstexpr frequency operator \"\"  _kHz(unsigned long long int val);\nconstexpr frequency operator \"\"  _MHz(long double val);\nconstexpr frequency operator \"\"  _MHz(unsigned long long int val);\n// duration\nconstexpr duration operator \"\"   _s(long double val);\nconstexpr duration operator \"\"   _s(unsigned long long int val);\nconstexpr duration operator \"\"   _ms(long double val);\nconstexpr duration operator \"\"   _ms(unsigned long long int val);\nconstexpr duration operator \"\"   _us(long double val);\nconstexpr duration operator \"\"   _us(unsigned long long int val);\n// decibel\nconstexpr decibel operator \"\"    _dB(unsigned long long int val);\nconstexpr decibel operator \"\"    _dB(long double val);\n// pi\nconstexpr long double operator \"\" _pi(long double val);\nconstexpr long double operator \"\" _pi(unsigned long long int val)\n</code></pre>"},{"location":"api/#notes","title":"Notes","text":"<p>There is also a complete set of tables for notes from A[0] (27.5Hz) to Ab[9] (13289.75Hz). For example, to get the frequencies for each of the open strings in a 6-string guitar:</p> <pre><code>   // 6 string guitar frequencies:\nconstexpr auto low_e   = E[2];\nconstexpr auto a       = A[2];\nconstexpr auto d       = D[3];\nconstexpr auto g       = G[3];\nconstexpr auto b       = B[3];\nconstexpr auto high_e  = E[4];\n</code></pre> <p>To use these literals, include the <code>notes.hpp</code> header:</p> <pre><code>   #include &lt;q/support/notes.hpp&gt;\n</code></pre> <p>then use the <code>notes</code> namespace somewhere in a scope where you need it:</p> <pre><code>   using namespace q::notes;\n</code></pre>"},{"location":"design/","title":"Design and Architecture","text":"<p>The Q library comprises of two layers:</p> <ol> <li> <p>q_lib: The core DSP library, which has no dependencies except the    standard c++ library. In the future, it is possible to make use additional    libraries, as long as the libraries depended upon are also self-contained.    q_lib is a no-frills, lightweight, header-only library.</p> </li> <li> <p>q_io: Audio and MIDI I/O layer, with very minimal dependencies    (portaudio and    portmidi) and very loose    coupling via thin wrappers that are easy to transplant and port to a host,    with or without an operating system, such as an audio plugin or direct to    hardware ADC and DAC.</p> </li> </ol> <p>By design, communication to and from the application, including but not limited to parameter control, is done exclusively via MIDI. We will track the development of the forthcoming (as of January 2019) MIDI 2.0, especially extended 16-bit and 32-bit resolution and MIDI Capability Inquiry (MIDI-CI) \"Universal System Exclusive\" messages.</p> <p>The architecture intuitively models real-world (hardware) effect processors (and synthesizers) with a) zero or more input channels and one or more output channels, and b) a means for communication and control via MIDI. Such design simplicity is fundamental. There is very clear separation of concerns. There are no graphical user interfaces. There are no direct hardware or software controls. User interface is outside the scope of the library. You deal with that elsewhere, or perhaps not at all.</p> <p>Such design simplicity makes it easy for applications to be incorporated in any hardware or software host. MIDI is a very simple protocol with a well defined and evolving standard. The ability to use any MIDI controller (again both hardware or software) to control an application is a very powerful and intuitive concept. It is the very concept that gave MIDI widespread appeal and ubiquity to begin with.</p> <p>This simplified control scheme using MIDI also allows applications to be easily testable in isolation \u2014a very desirable capability not typically found in more complex and monolithic systems.</p>"},{"location":"fundamentals/","title":"Fundamentals","text":""},{"location":"fundamentals/#file-structure","title":"File Structure","text":"<p>The library is organized with this simplified directory structure:</p> <pre><code>|_ docs:       Where this documentation resides.\n|_ example:    Self-contained and easy to understand c++ programs that\n|  demonstrate various features of the library.\n|_ q_io:\n|  |_ external: 3rd party libraries used by the `q_io` module.\n|  |_ include:  q_io header files.\n|  |_ src:      q_io source files.\n|_ q_lib:\n|  |_ include: Header-only core q_lib DSP library.\n|_ test: Contains a comprehensive set of c++ files for testing the library.\n</code></pre>"},{"location":"fundamentals/#namespace","title":"Namespace","text":"<p>All entities in the Q library are placed in namespace <code>cycfi::q</code>. Everywhere in this documentation, we will be using a namespace alias to make the code less verbose:</p> <pre><code>namespace q = cycfi::q;\n</code></pre>"},{"location":"fundamentals/#functors","title":"Functors","text":"<p>In the world of electronic music, there are processors and synthesizers, the definitions of which are somewhat overlapping and differ only on one specific point: that processors take in one or more input value(s) and produces one or more output value(s), whereas a synthesizer does not take in any inputs at all.</p> <p>In the Q world, both processors and synthesizers are just functors \u2014C++ function objects, which are basic building blocks that can be composed to form more complex functions. A functor can have zero or more input values and produces one or more output values (typically just one, but in certain cases, two or more output values may be returned in the form of C++ tuples).</p> <p>Syntactically, you use these just like any other function. So, for instance, for a single input functor:</p> <p><pre><code>float r = f(s);\n</code></pre> where <code>s</code> is the input value, and <code>f(s)</code> returns a result and stores it in the variable <code>r</code>. Typical audio processor functors in the Q DSP library work on 32-bit <code>float</code> input samples with the normal -1.0 to 1.0 range.</p>"},{"location":"fundamentals/#data-types","title":"Data Types","text":"<p>Values are not restricted to sampled signals, however. For an example, signal envelopes are best represented in the decibel domain, and so dynamic-range processors such as compressors and expanders take <code>decibel</code> as inputs and return <code>decibel</code> results. For example:</p> <pre><code>decibel gain = comp(env);\n</code></pre> <p>Another example, oscillators work on phase-angle inputs and return output samples:</p> <pre><code>float out = sin(phase++);\n</code></pre> <p>The Q DSP library has a rich set of such types:</p> <ul> <li><code>float</code>: Typical sample data type -1.0 to 1.0 (or beyond for some   computational headroom).</li> <li><code>frequency</code>: Cycles per second (Hz).</li> <li><code>duration</code> : A time span (seconds, milliseconds, etc.)</li> <li><code>period</code> : The inverse of frequency</li> <li><code>phase</code>: Fixed point 1.31 format where 31 bits are fractional. <code>phase</code>   represents 0 to 2\u03c0 phase values suitable for oscillators.</li> <li><code>decibel</code>: Ratio of one value to another on a logarithmic scale (dB)</li> </ul> <p>The Q DSP library is typeful and typesafe. You can not mismatch values of different types such as <code>frequency</code> and <code>decibel</code>, for example. Such potentially disastrous mistakes can happen if all values are just raw floating point types.</p> <p>Values do not have implicit conversion to raw types, however, except for <code>decibel</code>, which is special because it operates on the logarithmic domain, comparison and arithmetic with raw types are possible. For example:</p> <pre><code>   auto harmonic = 440_Hz * 4; // 440_Hz is a frequency literal (see below)\n</code></pre>"},{"location":"fundamentals/#value","title":"value","text":"<p>Type safe representation of a scalar value. <code>value</code> is a template parameterized by the underlying type, <code>T</code> and the derived class <code>Derived</code>.</p> <pre><code>template &lt;typename T, typename Derived&gt;\nstruct value;\n</code></pre>"},{"location":"fundamentals/#expressions","title":"Expressions","text":""},{"location":"fundamentals/#notation","title":"Notation","text":"<code>v</code> Scalar value. <code>a</code>, <code>b</code> Instance of <code>value&lt;T&gt;</code>"},{"location":"fundamentals/#constructors-and-assignment","title":"Constructors and assignment","text":"<pre><code>// Default constructor [1].\nvalue&lt;T&gt;{}\n// Constructor [2].\nvalue&lt;T&gt;{ v }\n// Copy constructor. [3]\nvalue&lt;T&gt;{ a }\n// Assignment [4]\na = b\n</code></pre>"},{"location":"fundamentals/#semantics","title":"Semantics","text":"<ol> <li>Default construct a <code>value&lt;T&gt;</code> with initial value <code>{ 0 }</code></li> <li>Construct a <code>value&lt;T&gt;</code> given initial value <code>v</code>.</li> <li>Copy construct a <code>value&lt;T&gt;</code>, <code>a</code>.</li> <li>Assign <code>b</code>, to <code>a</code>.</li> </ol>"},{"location":"fundamentals/#comparison","title":"Comparison","text":"<pre><code>a == b      // Equality\na == v      // Equality with a scalar\nv == b      // Equality with a scalar\na != b      // Non-equality\na != v      // Non-equality with a scalar\nv != b      // Non-equality with a scalar\na &lt; b       // Less than\na &lt; v       // Less than with a scalar\nv &lt; b       // Less than with a scalar\na &lt;= b      // Less than equal\na &lt;= v      // Less than equal with a scalar\nv &lt;= b      // Less than equal with a scalar\na &gt; b       // Greater than\na &gt; v       // Greater than with a scalar\nv &gt; b       // Greater than with a scalar\na &gt;= b      // Greater than equal\na &gt;= v      // Greater than equal with a scalar\nv &gt;= b      // Greater than equal with a scalar\n</code></pre>"},{"location":"fundamentals/#arithmetic","title":"Arithmetic","text":"<pre><code>+a          // Positive\n-a          // Negative\na += b      // Add assign\na -= b      // Subtract assign\na *= b      // Multiply assign\na /= b      // Divide assign\na + b       // Addition\na + v       // Addition with a scalar\nv + b       // Addition with a scalar\na - b       // Subtraction\na - v       // Subtraction with a scalar\nv - b       // Subtraction with a scalar\na * b       // Multiplication\na * v       // Multiplication with a scalar\nv * b       // Multiplication with a scalar\na / b       // Division\na / v       // Division with a scalar\nv / b       // Division with a scalar\n</code></pre>"},{"location":"fundamentals/#value-subclasses","title":"value subclasses","text":""},{"location":"fundamentals/#frequency","title":"frequency","text":"<p>Type safe representation of frequency in Hertz.</p> <pre><code>struct frequency : value&lt;double, frequency&gt;\n{\nconstexpr                     frequency(double val);\nconstexpr                     frequency(duration d);\nconstexpr explicit operator   double() const ;\nconstexpr explicit operator   float() const;\nconstexpr q::period           period() const;\n};\n</code></pre>"},{"location":"fundamentals/#expressions_1","title":"Expressions","text":"<p>In addition to valid expressions for <code>value&lt;T&gt;</code>, <code>frequency</code> allows these expressions.</p>"},{"location":"fundamentals/#notation_1","title":"Notation","text":"<code>d</code> Instance of <code>duration</code> (see below.) <code>f</code> Instance of <code>frequency</code>"},{"location":"fundamentals/#construction","title":"Construction","text":"<pre><code>// Construct a phase given the period (duration)\nphase{ d }\n</code></pre>"},{"location":"fundamentals/#conversions","title":"Conversions","text":"<pre><code>float(f)       // Convert frequency to a scalar (float)\ndouble(f)      // Convert frequency to a scalar (double)\n</code></pre>"},{"location":"fundamentals/#misc","title":"Misc","text":"<pre><code>f.period()     // get the period (1/f)\n</code></pre>"},{"location":"fundamentals/#duration","title":"duration","text":"<p>Type safe representation of duration.</p> <pre><code>struct duration : value&lt;double, duration&gt;\n{\nconstexpr                     duration(double val);\nconstexpr explicit operator   double() const;\nconstexpr explicit operator   float() const;\n};\n</code></pre>"},{"location":"fundamentals/#expressions_2","title":"Expressions","text":"<p>In addition to valid expressions for <code>value&lt;T&gt;</code>, <code>duration</code> allows these expressions.</p>"},{"location":"fundamentals/#notation_2","title":"Notation","text":"<code>d</code> Instance of <code>duration</code>"},{"location":"fundamentals/#conversions_1","title":"Conversions","text":"<pre><code>float(d)       // Convert duration to a scalar (float)\ndouble(d)      // Convert duration to a scalar (double)\n</code></pre>"},{"location":"fundamentals/#period","title":"period","text":"<p>Type safe representation of period (reciprocal of frequency).</p> <pre><code>struct period : duration\n{\nusing duration::duration;\nconstexpr                     period(duration d);\nconstexpr                     period(frequency f);\n};\n</code></pre>"},{"location":"fundamentals/#expressions_3","title":"Expressions","text":"<p>In addition to valid expressions for <code>value&lt;T&gt;</code>, <code>period</code> allows these expressions.</p>"},{"location":"fundamentals/#notation_3","title":"Notation","text":"<code>d</code> Instance of <code>duration</code> <code>f</code> Instance of <code>frequency</code> <code>p</code> Instance of <code>period</code>"},{"location":"fundamentals/#construction_1","title":"Construction","text":"<pre><code>// Construct a phase given a duration\nphase{ d }\n// Construct a phase given a frequency\nphase{ f }\n</code></pre>"},{"location":"fundamentals/#conversions_2","title":"Conversions","text":"<pre><code>float(p)       // Convert period to a scalar (float)\ndouble(p)      // Convert period to a scalar (double)\n</code></pre>"},{"location":"fundamentals/#phase","title":"phase","text":"<p>phase: The synthesizers use fixed point 1.31 format computations where 31 bits are fractional. phase represents phase values that run from 0 to 4294967295 (0 to 2\u03c0) suitable for oscillators.</p> <p>The turn, also cycle, full circle, revolution, and rotation, is a complete circular movement or measure (as to return to the same point) with circle or ellipse. A turn is abbreviated \u03c4, cyc, rev, or rot depending on the application. The symbol \u03c4 can also be used as a mathematical constant to represent 2\u03c0 radians.</p> <p>https://en.wikipedia.org/wiki/Angular_unit</p> <pre><code>struct phase : value&lt;std::uint32_t, phase&gt;\n{\nusing base_type = value&lt;std::uint32_t, phase&gt;;\nusing base_type::base_type;\nconstexpr static auto one_cyc = int_max&lt;std::uint32_t&gt;();\nconstexpr static auto bits = sizeof(std::uint32_t) * 8;\nconstexpr explicit            phase(value_type val = 0);\nconstexpr explicit            phase(float frac);\nconstexpr explicit            phase(double frac);\nconstexpr                     phase(frequency freq, float sps);\nconstexpr explicit operator   float() const;\nconstexpr explicit operator   double() const;\nconstexpr static phase        min();\nconstexpr static phase        max();\n};\n</code></pre>"},{"location":"fundamentals/#expressions_4","title":"Expressions","text":"<p>In addition to valid expressions for <code>value&lt;T&gt;</code>, <code>phase</code> allows these expressions.</p>"},{"location":"fundamentals/#notation_4","title":"Notation","text":"<code>f</code> A <code>double</code> or <code>float</code> <code>freq</code> Instance of <code>frequency</code> <code>sps</code> Scalar value <code>p</code> Instance of <code>phase</code>"},{"location":"fundamentals/#construction_2","title":"Construction","text":"<pre><code>// Construct a phase given the a fractional number from 0.0 to 1.0 (0 to 2\u03c0)\nphase{ f }\n// Construct a phase given the frequency and samples/second (`sps`)\nphase{ freq, sps }\n</code></pre>"},{"location":"fundamentals/#conversions_3","title":"Conversions","text":"<pre><code>float(p)       // Convert a phase to a scalar (float)\ndouble(p)      // Convert a phase to a scalar (double)\n</code></pre>"},{"location":"fundamentals/#min-and-max","title":"Min and Max","text":"<pre><code>phase::begin() // Get the minimum phase representing 0 degrees\nphase::end()   // Get the maximum phase representing 360 degrees (2\u03c0)\n</code></pre>"},{"location":"fundamentals/#decibel","title":"decibel","text":"<p>Decibel is unique. It does not inherit from <code>value&lt;T&gt;</code> because it is non-linear and operates on the logarithmic domain. The <code>decibel</code> class is perfectly suitable for dynamics processing (e.g. compressors and limiters and envelopes). Q provides fast decibel computations using lookup tables for converting to and from scalars.</p> <pre><code>struct decibel\n{\ndecibel();\ndecibel(double val);\nexplicit operator double() const;\nexplicit operator float() const;\nconstexpr decibel operator+() const;\nconstexpr decibel operator-() const;\ndouble val = 0.0f;\n};\n</code></pre>"},{"location":"fundamentals/#expressions_5","title":"Expressions","text":""},{"location":"fundamentals/#notation_5","title":"Notation","text":"<code>v</code> Scalar value. <code>a</code>, <code>b</code> Instance of <code>decibel</code>"},{"location":"fundamentals/#constructors-and-assignment_1","title":"Constructors and assignment","text":"<pre><code>// Default constructor [1].\ndecibel{}\n// Constructor [2].\ndecibel{ v }\n// Copy constructor. [3]\ndecibel{ a }\n// Assignment [4]\na = b\n</code></pre>"},{"location":"fundamentals/#semantics_1","title":"Semantics","text":"<ol> <li>Default construct a <code>decibel</code> with initial value <code>{ 0 }</code></li> <li>Construct a <code>decibel</code> given initial value <code>v</code>.</li> <li>Copy construct a <code>decibel</code>, <code>a</code>.</li> <li>Assign <code>b</code>, to <code>a</code>.</li> </ol>"},{"location":"fundamentals/#comparison_1","title":"Comparison","text":"<pre><code>a == b      // Equality\na != b      // Non-equality\na &lt; b       // Less than\na &lt;= b      // Less than equal\na &gt; b       // Greater than\na &gt;= b      // Greater than equal\n</code></pre>"},{"location":"fundamentals/#arithmetic_1","title":"Arithmetic","text":"<pre><code>+a          // Positive\n-a          // Negative\na += b      // Add assign\na -= b      // Subtract assign\na *= b      // Multiply assign\na /= b      // Divide assign\na + b       // Addition\na - b       // Subtraction\na * b       // Multiplication\na * v       // Multiplication with a scalar\nv * b       // Multiplication with a scalar\na / b       // Division\na / v       // Division with a scalar\n</code></pre>"},{"location":"fundamentals/#conversions_4","title":"Conversions","text":"<pre><code>float(a)    // Convert a decibel to a scalar (float)\ndouble(a)   // Convert a decibel to a scalar (double)\n</code></pre>"},{"location":"fundamentals/#literals","title":"Literals","text":"<p>To augment the wealth of value types, the Q DSP library makes abundant use of C++ user-defined literals.</p> <p>We take advantage of C++ (from c++11) type safe user-defined literals, instead of the usual <code>int</code>, <code>float</code> or <code>double</code> which can be unsafe when values from different units (e.g. frequency vs. duration) are mismatched. The Q DSP library makes abundant use of user-defined literals for units such as time, frequency and decibels (e.g. 24_dB, instead of a unit-less 24 or worse, a non-intuitive, unit-less 15.8 \u2014the gain equivalent of 24_dB). Such constants also make the code very readable, another objective of this library.</p> <p>Q Literals are placed in the namespace <code>q::literals</code>. The namespace is sparse enough to be hoisted into your namespace using <code>using namespace</code>:</p>"},{"location":"fundamentals/#example-expressions","title":"Example Expressions","text":""},{"location":"fundamentals/#frequencies","title":"Frequencies","text":"<pre><code>82.4069_Hz\n440_Hz\n1.5_KHz\n1.5_kHz\n1_KHz\n1_kHz\n0.5_MHz\n3_MHz\n</code></pre>"},{"location":"fundamentals/#durations","title":"Durations","text":"<pre><code>10.3_s\n1_s\n20.5_ms\n1_ms\n10.5_us\n500_us\n</code></pre>"},{"location":"fundamentals/#decibels","title":"Decibels","text":"<pre><code>-3.5_dB\n10_dB\n</code></pre>"},{"location":"fundamentals/#pi","title":"Pi","text":"<pre><code>2_pi\n0.5_pi\n</code></pre> <p>To use these literals, include the <code>literals.hpp</code> header:</p> <pre><code>#include &lt;q/support/literals.hpp&gt;\n</code></pre> <p>then use the <code>literals</code> namespace somewhere in a scope where you need it:</p> <pre><code>using namespace q::literals;\n</code></pre>"},{"location":"fundamentals/#notes","title":"Notes","text":"<p>There is also a complete set of tables for notes from <code>A[0]</code> (27.5Hz) to <code>Ab[9]</code> (13289.75Hz). For example, to get the frequencies for each of the open strings in a 6-string guitar:</p> <pre><code>// 6 string guitar frequencies:\nconstexpr auto low_e   = E[2];\nconstexpr auto a       = A[2];\nconstexpr auto d       = D[3];\nconstexpr auto g       = G[3];\nconstexpr auto b       = B[3];\nconstexpr auto high_e  = E[4];\n</code></pre> <p>To use these literals, include the <code>notes.hpp</code> header:</p> <pre><code>#include &lt;q/support/notes.hpp&gt;\n</code></pre> <p>then use the <code>notes</code> namespace somewhere in a scope where you need it:</p> <pre><code>using namespace q::notes;\n</code></pre>"},{"location":"hello_universe/","title":"Hello, Universe","text":"<p>Let us move on to a more elaborate example. How about a fully functional, bandwidth limited square wave synthesizer with ADSR envelope that controls an amplifier and a resonant filter and control the note-on and note-off using MIDI? Sounds good? This example is complete and self-contained in one .cpp file, kept as simple as possible to highlight the ease-of-use.</p> <p> \u00a0 The full example can be found here: example/square_synth.cpp.</p> <p>Here's a short video clip:</p> <p>After building the program, make sure you have a MIDI keyboard connected before starting the application. At startup, the app will present you with a list of available MIDI hardware and will ask you what you want to use:</p> <pre><code>================================================================================\nAvailable MIDI Devices (ID : \"Name\" inputs/outputs):\n0 : \"Code 61 USB MIDI\" 1/0\n1 : \"Code 61 MIDI DIN\" 1/0\n2 : \"Code 61 Mackie/HUI\" 1/0\n3 : \"Code 61 Editor\" 1/0\n4 : \"ZOOM R16_R24\" 1/0\n5 : \"Code 61 USB MIDI\" 0/1\n6 : \"Code 61 MIDI DIN\" 0/1\n7 : \"Code 61 Mackie/HUI\" 0/1\n8 : \"Code 61 Editor\" 0/1\n9 : \"ZOOM R16_R24\" 0/1\n================================================================================\nChoose MIDI Device ID: 0\n</code></pre> <p>And then a list of audio devices to choose from:</p> <pre><code>================================================================================\nAvailable Audio Devices (ID : \"Name\" inputs/outputs):\n0 : \"Built-in Microphone\" 2/0\n1 : \"Built-in Output\" 0/2\n2 : \"HDMI\" 0/2\n3 : \"ZOOM R16_R24 Driver\" 8/2\n================================================================================\nChoose Audio Device ID: 3\n</code></pre> <p>Take note that the demo is a console application. The Q library does not have a GUI, for good reason! We want to keep it as simple as possible. The GUI is taken cared of by other libraries (e.g. Elements).</p> <p>After choosing the MIDI and Audio driver, the synth is playable. The synth is monophonic and responds to velocity only, for simplicity.</p> <p>There are more demo applications in the example directory. After this quick tutorial, free to explore.</p>"},{"location":"hello_universe/#the-synth","title":"The Synth","text":"<p>Here's the actual synthesizer with the processing loop:</p> <pre><code>   struct my_square_synth : q::port_audio_stream\n{\nmy_square_synth(q::envelope::config env_cfg, int device_id)\n: port_audio_stream(q::audio_device::get(device_id), 0, 2)\n, env(env_cfg, this-&gt;sampling_rate())\n, filter(0.5, 0.8)\n{}\nvoid process(out_channels const&amp; out)\n{\nauto left = out[0];\nauto right = out[1];\nfor (auto frame : out.frames())\n{\n// Generate the ADSR envelope\nauto env_ = env();\n// Set the filter frequency\nfilter.cutoff(env_);\n// Synthesize the square wave\nauto val = q::square(phase++);\n// Apply the envelope (amplifier and filter) with soft clip\nval = clip(filter(val) * env_);\n// Output\nright[frame] = left[frame] = val;\n}\n}\nq::phase_iterator phase;            // The phase iterator\nq::envelope       env;              // The envelope\nq::reso_filter    filter;           // The resonant filter\nq::soft_clip      clip;             // Soft clip\n};\n</code></pre> <p>Our synth, a subclass of <code>q::port_audio_stream</code>, sets up buffers for the input and output audio streams and presents those to our processing loop (the <code>process</code> function above). In this example, we setup an audio stream with the selected device, no inputs and two (stereo) outputs:</p> <pre><code>port_audio_stream(q::audio_device::get(device_id), 0, 2)\n</code></pre>"},{"location":"hello_universe/#the-oscillator","title":"The Oscillator","text":"<p>Behind the scenes, there's a lot going on here, actually. But you will notice that emphasis is given to making the library very readable, easy to understand and follow by breaking down complex tasks into smaller manageable tasks and using function composition at progressively higher levels, while maintaining simplicity and clarity of intent.</p> <p>The synthesizer above is composed of smaller building blocks: fine grained C++ function objects. For example, here's the square wave oscillator (bandwidth limited using poly_blep).</p> <p> \u00a0 For now, we will skim over details such as the <code>envelope</code>, <code>phase</code>, and <code>phase_iterator</code>, and  and this thing called <code>poly blep</code>. The important point, exemplified here, is that we want to keep our building blocks as simple and minimal as possible. We will cover that in greater detail later.</p> <p>The astute reader may notice that our <code>square_synth</code> class does not even have state!</p> <pre><code>   struct square_synth\n{\nconstexpr float operator()(phase p, phase dt) const\n{\nconstexpr auto middle = phase::middle();\nauto r = p &lt; middle ? 1.0f : -1.0f;\n// Correct rising discontinuity\nr += poly_blep(p, dt);\n// Correct falling discontinuity\nr -= poly_blep(p + middle, dt);\nreturn r;\n}\nconstexpr float operator()(phase_iterator i) const\n{\nreturn (*this)(i._phase, i._incr);\n}\n};\nconstexpr auto square = square_synth{};\n</code></pre> <p>Yeah, that's the complete oscillator. That's all there is to it! </p> <p>The modern C++ savvy programmer will immediately notice the use of <code>constexpr</code>, applied judiciously all throughout the library. Such modern c++ facilities allow the compiler to generate extremely efficient code, even those that are generated at compile time. That means, for this example, that one can build an oscillator at compile time if needed, perhaps with constant wavetable results stored in read-only memory.</p>"},{"location":"hello_universe/#processing-midi","title":"Processing MIDI","text":"<p>The <code>midi_processor</code> takes care of MIDI events. Your application will have its own MIDI processor that deals with MIDI events that you are interested in. For this simple example, we simply want to process note-on and note-off events. On note-on events, our MIDI processor sets <code>my_square_synth</code>'s note frequency and triggers its envelope for attack. On note-off events, our MIDI processor initiates the envelope's release.</p> <pre><code>   struct my_midi_processor : midi::processor\n{\nusing midi::processor::operator();\nmy_midi_processor(my_square_synth&amp; synth)\n: _synth(synth)\n{}\nvoid operator()(midi::note_on msg, std::size_t time)\n{\n_key = msg.key();\nauto freq = midi::note_frequency(_key);\n_synth.phase.set(freq, _synth.sampling_rate());\n_synth.env.trigger(float(msg.velocity()) / 128);\n}\nvoid operator()(midi::note_off msg, std::size_t time)\n{\nif (msg.key() == _key)\n_synth.env.release();\n}\nstd::uint8_t      _key;\nmy_square_synth&amp;  _synth;\n};\n</code></pre>"},{"location":"hello_universe/#the-main-function","title":"The Main Function","text":"<p>In the main function, we instantiate <code>my_square_synth</code> and <code>my_midi_processor</code>. The synth constructor, in case you haven't noticed yet, requires an envelope configuration (<code>envelope::config</code>). Here, we provide our configuration. Take note that in this example, the envelope parameters are constant, for the sake of simplicity, but you can definitely have these controllable by the user by writing your own MIDI processor that deals with MIDI control change messages.</p> <p>Again, take note of the abundant use of user-defined literals for units such as duration (e.g. 100_ms) and level (e.g. -12_dB).</p> <pre><code>   auto env_cfg = q::envelope::config\n{\n100_ms      // attack rate\n, 1_s         // decay rate\n, -12_dB      // sustain level\n, 5_s         // sustain rate\n, 1_s         // release rate\n};\nmy_square_synth synth{ env_cfg };\n</code></pre> <p>Then, we create <code>my_midi_processor</code>, giving it a reference to <code>my_square_synth</code>. We'll also need a <code>midi_input_stream</code> that receives the actual incoming MIDI messages from the chosen hardware.</p> <pre><code>   q::midi_input_stream stream;\nmy_midi_processor proc{ synth };\n</code></pre> <p>Now we're all set. We start the synth and enter a loop that exits when the user presses ctrl-c (in which case the running flag becomes false). In the loop, we give our MIDI processor a chance to process incoming MIDI events as they arrive from the MIDI stream:</p> <pre><code>   synth.start();\nwhile (running)\nstream.process(proc);\nsynth.stop();\n</code></pre>"},{"location":"hello_world/","title":"Hello, World","text":"<p>Here's a quick \"Hello, World\" example that highlights the simplicity of the Q DSP Library: a delay effects processor.</p> <p> \u00a0 The full example can be found here: example/delay.cpp.</p> <p>The example loads a pre-recorded wav file and plays it back with processing. The raw audio source will be played in the left channel while the delayed signal will be played in the right channel. Pretty much as straightforward as possible. The audio will be played using the currently selected audio device.</p>"},{"location":"hello_world/#the-dsp-code","title":"The DSP Code","text":"<pre><code>   // 1: fractional delay\nq::delay _delay{ 350_ms, 44100 };\n// 2: Mix the signal s, and the delayed signal (where s is the incoming sample)\nauto _y = s + _delay();\n// 3: Feed back the result to the delay\n_delay.push(_y * _feedback);\n</code></pre> <p>Normally, there will be a processing loop that receives the incoming samples, <code>s</code>. You place #1, the delay constructor, <code>q::delay</code>, before the processing loop and #2 and #3 inside inside the loop.</p> <p>44100 is the desired sampling rate. _feedback is the amount of feedback desired (anything from 0.0 to less than 1.0, e.g. 0.85). But take note of <code>350_ms</code>. Here, we take advantage of C++ (from c++11) type safe user-defined literals, instead of the usual <code>float</code> or <code>double</code> which can be unsafe when values from different units (e.g. frequency vs. duration) are mismatched. The Q DSP library makes abundant use of user-defined literals for units such as time, frequency and even sound level (e.g. 24_dB, instead of a unit-less 24 or worse, a non-intuitive, unit-less 15.8 \u2014the gain equivalent of 24_dB). Such constants also make the code very readable, another objective of this library.</p> <p>Processors such as <code>q::delay</code> are C++ function objects (sometimes called functors) that can be composed to form more complex processors. For example if you want to filter the delayed signal with a low-pass with a 1 kHz cutoff frequency, you apply the <code>q::lowpass</code> filter over the result of the delay:</p> <pre><code>   q::lowpass _lp{ 1_kHz, 44100 };\n</code></pre> <p>then insert the filter where it is needed in the processing loop:</p> <pre><code>   // 2: Add the signal s, and the delayed, low-pass filtered signal\nauto _y = s + _lp(_delay());\n</code></pre>"},{"location":"setup/","title":"Setup and Installation","text":""},{"location":"setup/#requirements","title":"Requirements","text":"<p>Here are the basic requirements and dependencies that you need to satisfy in order to use the library:</p> <ol> <li>A C++17 compiler</li> <li>git</li> <li>CMake 3.5.1 or higher</li> </ol> <p>Additionally, the following libraries are dragged as submodules:</p> <ol> <li>The Cycfi infra library</li> <li>portaudio Audio I/O library.</li> <li>portmidi MIDI I/O library.</li> </ol>"},{"location":"setup/#c17","title":"C++17","text":"<p>Q currently supports the macOS, Windows and Linux. In the Mac, we support both XCode. Q is tested with XCode 10 and XCode 11. In Windows, we support Windows 10 with Visual Studio 2019, although it will probably also work with older versions of the Visual Studio IDE. In Linux, we support both Clang and g++ Get the latest version with a C++17 compiler. The CLion IDE is supported on all platforms.</p>"},{"location":"setup/#git","title":"Git","text":"<p>Clone the Q DSP library and its submodules:</p> <pre><code>git clone --recurse-submodules https://github.com/cycfi/Q.git\n</code></pre>"},{"location":"setup/#cmake","title":"CMake","text":"<p>Make sure you have CMake 3.5.1 or higher. Follow the installation procedure for your platform.</p>"},{"location":"setup/#generating-the-project-using-cmake","title":"Generating the Project using CMake","text":"<p>There are multiple ways to generate a project file using CMake depending on your platform and desired IDE, but here are some examples for macOS 10.14, Windows 10 and, and Ubuntu 16.04:</p>"},{"location":"setup/#macos","title":"macOS","text":"<p>Using XCode:</p> <ol> <li>CD to the Q library: <code>cd Q</code></li> <li>Make a build directory: 'mkdir build'</li> <li>CD to the the Q/build directory: <code>cd build</code></li> <li>Invoke cmake: <code>cmake -G\"Xcode\" ../</code></li> </ol> <p>If successful, cmake will generate an XCode project in the build directory.</p>"},{"location":"setup/#windows","title":"Windows","text":"<p>Using Visual Studio 2019</p> <ol> <li>CD to the Q library: <code>cd Q</code></li> <li>Make a build directory: 'mkdir build'</li> <li>CD to the the Q/build directory: <code>cd build</code></li> <li>Invoke cmake: <code>cmake -G\"Visual Studio 16 2019\" ../</code></li> </ol> <p>If successful, cmake will generate an Visual Studio solution project in the build directory.</p>"},{"location":"setup/#linux","title":"Linux","text":"<p>Using dpkg packaging system, stock g++ compiler and CodeBlocks.</p> <ol> <li>Install portaudio dependencies: <code>sudo apt-get install libasound-dev</code></li> <li>CD to the Q library: <code>cd Q</code></li> <li>Make a build directory: 'mkdir build'</li> <li>CD to the the Q/build directory: <code>cd build</code></li> <li>Invoke cmake: <code>cmake -G\"CodeBlocks - Unix Makefiles\" ../</code></li> </ol> <p>If successful, cmake will generate a CodeBlocks project in the build directory.</p>"},{"location":"setup/#build-and-test","title":"Build and Test","text":"<p>Build the project generated by cmake.</p> <p>Try running the tests and examples. If you intend to run the executables directly from the command line, make sure to change the directory to the same level where the <code>audio_files</code> is (e.g. 1 folder up on XCode builds). Some tests and examples may require audio clips that are found in this folder.</p> <p>To make sure everything is OK, try running the <code>sin_synth.cpp</code> example. Make sure your system's default audio device is set up and ready to play audio. The <code>sin_synth.cpp</code> program should play a 5 second 440 Hz sine wave. You might also want to try running the <code>list_devices.cpp</code> example that prints out all detected audio and MIDI devices.</p>"},{"location":"using_fx/","title":"Using FX","text":""},{"location":"using_fx/#biquad-filters-and-delay","title":"Biquad filters and delay","text":"<p>Let's take a look into applying some fx in real time on a test audio file. In particular we're going to look into some biquad highpass and lowpass filters as well as a delay effect. This examples are complete and self-contained in one .cpp file, kept as simple as possible to highlight the ease-of-use.</p> <p>Make sure you have a working sound system and the volume is up :)</p> <p>Take note that the demo is a console application. The Q library does not have a GUI, for good reason! We want to keep it as simple as possible. The GUI is taken cared of by other libraries (e.g. Elements).</p> <p>There are more demo applications in the example directory. After this quick tutorial, free to explore.</p>"},{"location":"using_fx/#the-fx-processor","title":"The FX processor","text":"<p>Here's the filter processor:</p> <pre><code>   struct filter_processor : q::port_audio_stream\n{\nfilter_processor(\nq::wav_memory&amp; wav\n, q::frequency hpfFreq\n, q::frequency lpfFreq\n)\n: port_audio_stream(0, 2, wav.sps())\n, _wav(wav)\n, _hpf(hpfFreq, wav.sps())\n, _lpf(lpfFreq, wav.sps())\n{}\nvoid process(out_channels const&amp; out)\n{\nauto left = out[0];\nauto right = out[1];\nfor (auto frame : out.frames())\n{\n// Get the next input sample\nauto s = _wav()[0];\n// Cascaded highpass and lowpass processing\n_y = _hpf(s),\n_y = _lpf(_y);\n// Output\nleft[frame] = _y;\nright[frame] = _y;\n}\n}\nq::wav_memory&amp;    _wav;\nq::highpass      _hpf;\nq::lowpass       _lpf;\nfloat             _y = 0.0f;\n};\n</code></pre> <p>As seen in other examples too, this is a subclass of <code>q::port_audio_stream</code>. We setup an audio stream with the default settings and provide the output audio stream to our processing loop (the <code>process</code> function seen above).</p> <pre><code>   filter_processor(\nq::wav_memory&amp; wav\n, q::frequency hpfFreq\n, q::frequency lpfFreq\n)\n: port_audio_stream(0, 2, wav.sps())\n, _wav(wav)\n, _hpf(hpfFreq, wav.sps())\n, _lpf(lpfFreq, wav.sps())\n{}\n</code></pre> <p>Moreover, we provide the class with the data of a wave file loaded from the hard disk as well as settings for the filters, namely cutoff frequencies. The sampling frequency is of course defined by the wave file. The filters are initialized:</p> <pre><code>   _hpf(hpfFreq, wav.sps())\n</code></pre> <pre><code>   _lpf(lpfFreq, wav.sps())\n</code></pre> <p>Now let's take a closer look at the very \"flesh\" of our example, our process function:</p> <pre><code>   void process(out_channels const&amp; out)\n{\nauto left = out[0];\nauto right = out[1];\nfor (auto frame : out.frames())\n{\n// Get the next input sample\nauto s = _wav()[0];\n// Cascaded highpass and lowpass processing\n_y = _hpf(s),\n_y = _lpf(_y);\n// Output\nleft[frame] = _y;\nright[frame] = _y;\n}\n}\n</code></pre> <p>The first two lines give us access to the audio output stream:</p> <pre><code>   auto left = out[0];\nauto right = out[1];\n</code></pre> <p>Then we loop through all the samples in the wave file, fetching one-by-one:</p> <pre><code>   auto s = _wav()[0];\n</code></pre> <p>And apply our filters in cascade to the every sample:</p> <pre><code>   _y = _hpf(s),\n_y = _lpf(_y);\n</code></pre> <p>And finally send the processed sample off to the output stream:</p> <pre><code>   left[frame] = _y;\nright[frame] = _y;\n</code></pre>"},{"location":"using_fx/#the-main-function","title":"The Main Function","text":"<p>In the main function, we make sure to load our test audio file.</p> <pre><code>   q::wav_memory     wav{ \"audio_files/Low E.wav\" };\n</code></pre> <p>The we initialize our audio stream by providing with the wave file and some drastic cutoff frequencies to make the result of the processing very apparent.</p> <pre><code>   filter_processor   proc{ wav, 1_kHz, 2_kHz };\n</code></pre> <p>Now we're ready to start the audio stream and wait for the audio file to be played to the end.</p> <pre><code>   if (proc.is_valid())\n{\nproc.start();\nq::sleep(q::duration(wav.length()) / wav.sps());\nproc.stop();\n}\n</code></pre>"},{"location":"using_fx/#delay-effects","title":"Delay effects","text":"<p>Similarly, in the delay.cpp example also found in the example folder, we have our delay processor:</p> <pre><code>   struct delay_processor : q::port_audio_stream\n{\ndelay_processor(\nq::wav_memory&amp; wav\n, q::duration delay\n, float feedback\n)\n: port_audio_stream(0, 2, wav.sps())\n, _wav(wav)\n, _delay(delay, wav.sps())\n, _feedback(feedback)\n{}\nvoid process(out_channels const&amp; out)\n{\nauto left = out[0];\nauto right = out[1];\nfor (auto frame : out.frames())\n{\n// Get the next input sample\nauto s = _wav()[0];\n// Mix the signal and the delayed signal\n_y = s + _delay();\n// Feed back the result to the delay\n_delay.push(_y * _feedback);\n// Output\nleft[frame] = s;\nright[frame] = _y;\n}\n}\nq::wav_memory&amp;    _wav;\nq::delay          _delay;\nfloat             _feedback;\nfloat             _y = 0.0f;\n};\n</code></pre> <p>The only difference here is that we initialize a delay effect and provide a value (between 0 to 1) to define how much feedback the delay will have:</p> <pre><code>   _delay(delay, wav.sps())\n</code></pre> <pre><code>   _feedback(feedback)\n</code></pre> <p>In our process loop we mix the current sample with the sum of delayed samples and make sure to push the new sample to the delay stack with the defined feedback gain.</p> <p><pre><code>   _y = s + _delay();\n_delay.push(_y * _feedback);\n</code></pre> In the main function we make sure to initiliaze our delay processor with the test audio file and delay and feedback parameters.</p> <pre><code>   delay_processor   proc{ wav, 350_ms, 0.85f };\n</code></pre>"},{"location":"common/","title":"Cycfi MKDocs Material theme files","text":"<p>Common files shared between projects' documentation.</p>"}]}